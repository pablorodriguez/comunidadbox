require 'digest/sha1'
class User < ActiveRecord::Base

  # Get Imge from GRAvatar
  is_gravtastic(:size=> 50,:default =>"mm")

  # Virtual attribute for the unencrypted password
  attr_accessor :password, :hasCompany, :need_pass_validation
  attr :new_password ,true

  has_many :service_filters
  has_many :cars
  
  belongs_to :creator,:class_name=>'User'
  belongs_to :company
  belongs_to :supplier, :class_name => 'Company', :foreign_key => 'supplier_id'
  has_many :user_roles
  has_many :roles ,:through => :user_roles
  
  has_many :user_addresses,:dependent => :destroy
  has_many :addresses, :through => :user_addresses
  
  has_many :alarms, :dependent => :destroy

  validates_presence_of :email
  validates_presence_of :password, :if => :password_required?
  validates_presence_of :password_confirmation, :if => :password_required?
  validates_length_of :password, :within => 4..40, :if => :password_required?
  validates_confirmation_of :password, :if => :password_required?
  validates_uniqueness_of :email, :case_sensitive => false
  before_save :encrypt_password

  accepts_nested_attributes_for :addresses,:reject_if => lambda {|a| a[:name].blank?},:allow_destroy => true
  accepts_nested_attributes_for :user_addresses,:allow_destroy => true
  accepts_nested_attributes_for :company,:reject_if =>lambda {|a| a[:name].blank?}
  accepts_nested_attributes_for :cars,:reject_if=>lambda{|a| a[:domain].blank?},:allow_destroy => true
  
  validate :validate_addresses
  
  def validate_addresses
    if addresses.nil?
      errors.add_to_base("Debe seleccionar una direcciÃ³n como valida")      
    end
  end
  
  COMP_TYPES = [
    # Displayed stored in db
    [ 'Administrador' , 'company_admin' ],
    [ 'Empleado' , 'company_employee' ]
  ]
  
  def address
    user_addresses.select{|a| a.active != 0 }[0].address
  end

  def future_events
    company_cars = Car.find(:all,:conditions=>["user_id = ? ",id])
    cars_ids = company_cars.each{|c|c.id.to_i}
    Event.all(:conditions=>["dueDate >= ? and car_id in(?)",Time.now,cars_ids])
  end

  def company?
    company != nil
  end

  def is_company_admin
    find_role "company_admin"
  end

  def is_super_admin
    find_role "super_admin"
  end
  
  def is_company_employee
    find_role "company_employee"
  end

  def find_role(role_name)
    roles.select{|r| r.name == role_name}[0] != nil
  end

  # Authenticates a user by their login name and unencrypted password. Returns the user or nil.
  def self.authenticate(email, password)
    u = find_by_email(email) # need to get the salt
    unless u.nil? 
      if u.active
        u.authenticated?(password) ? u : nil
      end
    else
      nil
    end
  end

  def full_name
    "#{first_name.capitalize} #{last_name.capitalize}"
  end

  # Encrypts some data with the salt.
  def self.encrypt(password, salt)
    Digest::SHA1.hexdigest("--#{salt}--#{password}--")
  end

  # Encrypts the password with the user salt
  def encrypt(password)
    self.class.encrypt(password, salt)
  end

  def authenticated?(password)
    crypted_password == encrypt(password)
  end

  def remember_token?
    remember_token_expires_at && Time.now.utc < remember_token_expires_at
  end

  # These create and unset the fields required for remembering users between browser closes
  def remember_me
    self.remember_token_expires_at = 2.weeks.from_now.utc
    self.remember_token = encrypt("#{email}--#{remember_token_expires_at}")
    save(false)
  end

  def forget_me
    self.remember_token_expires_at = nil
    self.remember_token = nil
    save(false)
  end

  def price_list
    if company
      PriceList.find_by_company_id_and_active company.id,1
    end
  end

  def self.email_confirmation(user)
    begin
      logger.debug "entro en email_confirmation"
      result = MiddleMan.worker(:mailer_worker).async_user_activation_notification(:arg => user.id)
      logger.debug "Mailer sent #{result}"
    rescue Exception => e
      logger.debug "Error #{e} (#{e.class})!"
    end
  end

  protected
  # before filter
  def encrypt_password
    return if password.blank?
    self.salt = Digest::SHA1.hexdigest("--#{Time.now.to_s}--#{first_name}--") if new_record?
    self.crypted_password = encrypt(password)
  end

  def password_required?
    (need_pass_validation) && (crypted_password.blank? || !password.blank?)
  end
end

